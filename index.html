<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Arch Guide â€“ All Buildings Map</title>

  <script src="https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.js" crossorigin></script>

  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; }
    #map { width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // --- CONFIG ---
    const SUPABASE_URL = 'https://msuzmrfzzkqffhpilirb.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1zdXptcmZ6emtxZmZocGlsaXJiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY3NjY5NDAsImV4cCI6MjA4MjM0Mjk0MH0.kGHLaDT2FR9AAnZjP96FgAcSPjCQm6w9ifAqd6cEOoQ';
    
    const MAPKIT_TOKEN = 'eyJraWQiOiJSN05HVzZZNko3IiwidHlwIjoiSldUIiwiYWxnIjoiRVMyNTYifQ.eyJpc3MiOiI4N05MV1VQUVFBIiwiaWF0IjoxNzY3NjcxMDk2LCJvcmlnaW4iOiJhcmNoZ3VpZGUuZ2l0aHViLmlvIn0.aGopUszusE4HfaiqItorz1NoVxzy5z46YItwrq43WVgyERsMm8kkmLZMJNUHd83c-icIhRra2mBFwgpdvYk-SA';

    const NEIGHBORHOOD_COLORS = {
      'DTL': '#1150AB',
      'SLV': '#2E7D6F',
      'PAS': '#C56B3C',
      'LFZ': '#E85D75',
      'WHO': '#F4A261'
    };

    // --- Get user_id from URL ---
    const params = new URLSearchParams(window.location.search);
    const USER_ID = params.get('user_id');
    if (!USER_ID) {
      document.body.innerHTML = '<div style="padding:20px;color:red;">Error: user_id required</div>';
      throw new Error('USER_ID missing from URL');
    }

    // --- MapKit Init ---
    mapkit.init({
      authorizationCallback: function(done) {
        done(MAPKIT_TOKEN);
      }
    });

    const map = new mapkit.Map("map", {
      center: new mapkit.Coordinate(34.0522, -118.2437),
      region: new mapkit.CoordinateRegion(
        new mapkit.Coordinate(34.0522, -118.2437),
        new mapkit.CoordinateSpan(0.4, 0.5)
      ),
      showsCompass: mapkit.FeatureVisibility.Hidden,
      showsScale: false,
      showsMapTypeControl: false,
      isZoomEnabled: true,
      isScrollEnabled: true
    });

    // --- State ---
    let allBuildings = [];
    let unlockedSet = new Set();
    let tourSet = new Set();
    let lastFilterStateJson = "";
    let buildingAnnotations = [];

    // --- Helper: Supabase fetch ---
    async function supaJson(path) {
      const res = await fetch(`${SUPABASE_URL}${path}`, {
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Accept': 'application/json'
        }
      });
      if (!res.ok) {
        const error = await res.text();
        console.error('Supabase error:', error);
        throw new Error(`Supabase: ${res.status} ${error}`);
      }
      return res.json();
    }

    // --- Load data once ---
    async function loadBuildingsOnce() {
      allBuildings = await supaJson(
        `/rest/v1/buildings?select=id,title,latitude,longitude,image,neighborhood_id,is_free`
      );
      console.log(`Loaded ${allBuildings.length} buildings`);
    }

    async function loadUnlockedOnce() {
      try {
        const rows = await supaJson(
          `/rest/v1/user_building_unlocks?user_id=eq.${encodeURIComponent(USER_ID)}&select=building_id`
        );
        unlockedSet = new Set(rows.map(r => r.building_id));
        console.log(`User has ${unlockedSet.size} unlocked buildings`);
      } catch (err) {
        console.log('No unlocked buildings table or data');
        unlockedSet = new Set();
      }
    }

    async function loadTourSet(tour_id) {
      if (!tour_id) { 
        tourSet = new Set(); 
        return; 
      }
      try {
        const rows = await supaJson(
          `/rest/v1/tour_stops?tour_id=eq.${encodeURIComponent(tour_id)}&select=building_id`
        );
        tourSet = new Set(rows.map(r => r.building_id));
        console.log(`Tour has ${tourSet.size} stops`);
      } catch (err) {
        console.log('No tour stops table or data');
        tourSet = new Set();
      }
    }

    // --- Pin management ---
    function clearPins() {
      buildingAnnotations.forEach(a => map.removeAnnotation(a));
      buildingAnnotations = [];
    }

    function addPins(buildings) {
      buildings.forEach(b => {
        if (!b.latitude || !b.longitude) return;

        const ann = new mapkit.MarkerAnnotation(
          new mapkit.Coordinate(Number(b.latitude), Number(b.longitude)),
          {
            color: NEIGHBORHOOD_COLORS[b.neighborhood_id] || '#666666',
            glyphText: '',
            title: b.title,
            data: b
          }
        );

        ann.callout = {
          calloutElementForAnnotation: function(annotation) {
            const building = annotation.data;
            const callout = document.createElement('div');
            callout.style.cssText = `
              width:155px;height:155px;border-radius:12px;overflow:hidden;
              box-shadow:0 8px 24px rgba(0,0,0,0.25);cursor:pointer;background:white;
            `;
            callout.innerHTML = building.image
              ? `<img src="${building.image}" alt="${building.title}" style="width:100%;height:100%;object-fit:cover;display:block;" />`
              : `<div style="width:100%;height:100%;background:#ddd;display:flex;align-items:center;justify-content:center;font-size:14px;color:#666;">No Image</div>`;

            callout.addEventListener('click', () => {
              if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                  action: 'navigateToBuilding',
                  buildingId: building.id,
                  buildingTitle: building.title
                }));
              }
            });

            return callout;
          }
        };

        map.addAnnotation(ann);
        buildingAnnotations.push(ann);
      });

      if (buildingAnnotations.length) {
        map.showItems(buildingAnnotations);
      }
      console.log(`Showing ${buildingAnnotations.length} pins`);
    }

    // --- Apply filter logic ---
    function applyFilterState(state) {
      const showFree = state.show_free === true;
      const showLocked = state.show_locked === true;
      const showUnlocked = state.show_unlocked === true;
      const tour_id = state.tour_id || null;

      let list = allBuildings;

      // If tour mode, restrict to tour stops
      if (tour_id) {
        list = list.filter(b => tourSet.has(b.id));
      }

      // Filter by unlock status
      list = list.filter(b => {
        const isFree = b.is_free === true;
        const isUnlocked = !isFree && unlockedSet.has(b.id);
        const isLocked = !isFree && !unlockedSet.has(b.id);

        return (showFree && isFree) || (showUnlocked && isUnlocked) || (showLocked && isLocked);
      });

      clearPins();
      addPins(list);
    }

    // --- Poll filter state from DB ---
    async function pollFilterState() {
      try {
        const rows = await supaJson(
          `/rest/v1/map_state?user_id=eq.${encodeURIComponent(USER_ID)}&select=show_free,show_locked,show_unlocked,tour_id&limit=1`
        );

        const state = rows && rows[0];
        if (!state) {
          // No state yet - use defaults (show all)
          return;
        }

        const stateJson = JSON.stringify({
          show_free: state.show_free,
          show_locked: state.show_locked,
          show_unlocked: state.show_unlocked,
          tour_id: state.tour_id
        });

        // Only update if changed
        if (stateJson !== lastFilterStateJson) {
          lastFilterStateJson = stateJson;

          // If tour changed, refresh tour stops
          await loadTourSet(state.tour_id);

          applyFilterState(state);
        }
      } catch (err) {
        console.error('Poll error:', err);
      }
    }

    // --- Boot ---
    (async function boot() {
      try {
        await loadBuildingsOnce();
        await loadUnlockedOnce();

        // Show all by default
        clearPins();
        addPins(allBuildings);

        // Start polling
        await pollFilterState();
        setInterval(pollFilterState, 700);
      } catch (err) {
        console.error('Boot error:', err);
        document.body.innerHTML = `<div style="padding:20px;color:red;">Error: ${err.message}</div>`;
      }
    })();
  </script>
</body>
</html>
